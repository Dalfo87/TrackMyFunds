// src/routes/transactions.ts

import express from 'express';
import Transaction, { ITransaction, TransactionType, PaymentMethod, STABLECOINS } from '../models/Transaction';
import Portfolio from '../models/Portfolio';

// Definisci esplicitamente il router
const router = express.Router();

// Definisci un tipo personalizzato per i gestori delle richieste
type RequestHandler = (
  req: express.Request,
  res: express.Response,
  next?: express.NextFunction
) => Promise<any> | any;

/**
 * Ricalcola l'intero portafoglio basandosi su tutte le transazioni
 * Con supporto per saldi negativi, conversioni da crypto a stablecoin e farming
 */
async function recalculatePortfolio(user: string) {
  try {
    // Ottieni tutte le transazioni dell'utente, escludendo quelle generate automaticamente
    // e ordinandole per data
    const transactions = await Transaction.find({ 
      user,
      isAutoGenerated: { $ne: true } 
    }).sort({ date: 1 });
    
    // Crea un nuovo portafoglio vuoto (o recupera quello esistente)
    let portfolio = await Portfolio.findOne({ user });
    if (!portfolio) {
      portfolio = new Portfolio({
        user,
        assets: [],
        lastUpdated: new Date()
      });
    } else {
      // Resetta gli asset se il portafoglio esiste già
      portfolio.assets = [];
    }
    
    console.log(`Ricalcolo portafoglio per utente ${user}: ${transactions.length} transazioni originali trovate`);
    
    // Elabora ogni transazione per ricostruire il portafoglio
    for (const tx of transactions) {
      // Normalizza il simbolo della criptovaluta per evitare problemi di case-sensitivity
      const normalizedSymbol = tx.cryptoSymbol.trim().toUpperCase();
      
      // Trova l'asset nel portafoglio usando il simbolo normalizzato
      const assetIndex = portfolio.assets.findIndex(
        asset => asset.cryptoSymbol.trim().toUpperCase() === normalizedSymbol
      );
      
      console.log(`Transazione ${tx._id}: Tipo=${tx.type}, Crypto=${normalizedSymbol}, Quantità=${tx.quantity}`);
      
      // ACQUISIZIONI (BUY, AIRDROP)
      if (tx.type === TransactionType.BUY || tx.type === TransactionType.AIRDROP) {
        // Determina se questa è una transazione a costo zero
        const isZeroCost = tx.type === TransactionType.AIRDROP;
        const assetType = isZeroCost ? 'airdrop' : 'crypto';
        
        if (assetIndex === -1) {
          // Se l'asset non esiste nel portafoglio, aggiungilo
          portfolio.assets.push({
            cryptoSymbol: normalizedSymbol,
            quantity: tx.quantity,
            averagePrice: isZeroCost ? 0 : tx.pricePerUnit,
            category: tx.category,
            type: assetType
          });
          console.log(`Aggiunto nuovo asset (${tx.type}): ${normalizedSymbol}, Quantità=${tx.quantity}`);
        } else {
          // Se l'asset esiste, aggiorna quantità e prezzo medio
          const asset = portfolio.assets[assetIndex];
          
          if (isZeroCost) {
            // Per acquisizioni a costo zero, aggiusta il prezzo medio ponderato
            if (asset.quantity === 0) {
              asset.averagePrice = 0;
            } else {
              const totalValue = asset.quantity * asset.averagePrice;
              asset.averagePrice = totalValue / (asset.quantity + tx.quantity);
            }
          } else {
            // Per acquisti normali, calcola il nuovo prezzo medio ponderato
            const totalValue = asset.quantity * asset.averagePrice + tx.quantity * tx.pricePerUnit;
            const newQuantity = asset.quantity + tx.quantity;
            asset.averagePrice = totalValue / newQuantity;
          }
          
          // Incrementa la quantità in ogni caso
          asset.quantity += tx.quantity;
          
          // Aggiorna la categoria se fornita
          if (tx.category) asset.category = tx.category;
          
          console.log(`${tx.type} aggiornato: ${normalizedSymbol}, Nuova quantità=${asset.quantity}, Nuovo prezzo medio=${asset.averagePrice}`);
        }
      } 
      // FARMING
      else if (tx.type === TransactionType.FARMING) {
        if (assetIndex === -1) {
          // Se la crypto guadagnata non esiste nel portafoglio, la aggiungiamo
          portfolio.assets.push({
            cryptoSymbol: normalizedSymbol,
            quantity: tx.quantity,
            averagePrice: 0,  // Prezzo medio sempre a zero per il farming
            category: tx.category,
            type: 'farming'
          });
          console.log(`Aggiunto nuovo asset da farming: ${normalizedSymbol}, Quantità=${tx.quantity}`);
        } else {
          // Se la crypto guadagnata esiste, aumentiamo la quantità
          const asset = portfolio.assets[assetIndex];
          
          // Calcola il nuovo prezzo medio ponderato considerando che il farming è a costo zero
          if (asset.quantity === 0) {
            asset.averagePrice = 0;
          } else {
            const totalValue = asset.quantity * asset.averagePrice;
            asset.averagePrice = totalValue / (asset.quantity + tx.quantity);
          }
          
          asset.quantity += tx.quantity;
          console.log(`Farming aggiornato: ${normalizedSymbol}, Nuova quantità=${asset.quantity}`);
        }
        
        // Tracciamo la crypto di origine per reference
        if (tx.paymentCurrency && tx.paymentCurrency !== normalizedSymbol) {
          console.log(`Crypto di origine per farming: ${tx.paymentCurrency}`);
        }
      }
      // VENDITE (SELL)
      else if (tx.type === TransactionType.SELL) {
        if (assetIndex !== -1) {
          // L'asset esiste nel portafoglio
          const asset = portfolio.assets[assetIndex];
          console.log(`Vendita: ${normalizedSymbol}, Quantità attuale=${asset.quantity}, Quantità da vendere=${tx.quantity}`);
          
          const oldQuantity = asset.quantity;
          
          // CORREZIONE BUG: Sottraggo la quantità SOLO UNA VOLTA
          asset.quantity -= tx.quantity;
          
          console.log(`Vendita completata: ${normalizedSymbol}, Nuova quantità=${asset.quantity}`);

          // Aggiorniamo il prezzo medio solo se passiamo da positivo a negativo
          if (oldQuantity > 0 && asset.quantity < 0) {
            asset.averagePrice = tx.pricePerUnit;
            console.log(`Quantità passata da positiva a negativa, nuovo prezzo medio=${asset.averagePrice}`);
          }
        } else {
          // L'asset non esiste nel portafoglio, lo creiamo con quantità negativa
          console.log(`Vendita di asset non presente nel portafoglio: ${normalizedSymbol}, creazione con saldo negativo`);
          
          portfolio.assets.push({
            cryptoSymbol: normalizedSymbol,
            quantity: -tx.quantity, // Inizializza con quantità negativa
            averagePrice: tx.pricePerUnit, // Il prezzo medio è il prezzo della vendita
            category: tx.category,
            type: 'crypto'
          });
          
          console.log(`Creato nuovo asset con quantità negativa: ${normalizedSymbol}, Quantità=-${tx.quantity}`);
        }
        
        // Gestione speciale per le vendite con metodo di pagamento crypto (stablecoin)
        if (tx.paymentMethod === PaymentMethod.CRYPTO && tx.paymentCurrency) {
          const stablecoinSymbol = tx.paymentCurrency.trim().toUpperCase();
          
          // Verifica se è una stablecoin riconosciuta
          if (STABLECOINS.includes(stablecoinSymbol)) {
            console.log(`Vendita con ricezione di stablecoin: ${stablecoinSymbol}`);
            
            // Calcola l'importo in stablecoin (1:1 con USD)
            const stablecoinAmount = tx.totalAmount;
            
            // Cerca la stablecoin nel portafoglio
            const stablecoinIndex = portfolio.assets.findIndex(
              asset => asset.cryptoSymbol.trim().toUpperCase() === stablecoinSymbol
            );
            
            if (stablecoinIndex === -1) {
              // Se la stablecoin non esiste, la aggiungiamo
              portfolio.assets.push({
                cryptoSymbol: stablecoinSymbol,
                quantity: stablecoinAmount,
                averagePrice: 1.0, // Le stablecoin hanno sempre prezzo 1:1 con USD
                category: 'stablecoin',
                type: 'stablecoin'
              });
              
              console.log(`Aggiunta nuova stablecoin: ${stablecoinSymbol}, Quantità=${stablecoinAmount}`);
            } else {
              // Se la stablecoin esiste, aumentiamo la quantità
              const stablecoinAsset = portfolio.assets[stablecoinIndex];
              stablecoinAsset.quantity += stablecoinAmount;
              
              console.log(`Aggiornata stablecoin: ${stablecoinSymbol}, Nuova quantità=${stablecoinAsset.quantity}`);
            }
            
            // Registra una transazione di acquisto automatico per la stablecoin
            const stablecoinTransaction = new Transaction({
              user,
              cryptoSymbol: stablecoinSymbol,
              type: TransactionType.BUY,
              quantity: stablecoinAmount,
              pricePerUnit: 1.0, // Prezzo fisso 1:1 con USD
              totalAmount: stablecoinAmount,
              date: tx.date,
              notes: `Generato automaticamente dalla vendita di ${tx.quantity} ${normalizedSymbol}`,
              category: 'stablecoin',
              paymentMethod: PaymentMethod.CRYPTO,
              paymentCurrency: normalizedSymbol,
              isAutoGenerated: true // Flag per indicare che è generata automaticamente
            });
            
            // Salva la transazione stablecoin nel database
            await stablecoinTransaction.save();
            console.log(`Creata transazione automatica per acquisto di ${stablecoinAmount} ${stablecoinSymbol}`);
          }
        }
      }
    }

    // Correggi eventuali prezzi medi anomali
    portfolio.assets.forEach(asset => {
      // Se il prezzo medio è NaN, Infinity, null, undefined o negativo, imposta un valore di default
      if (isNaN(asset.averagePrice) || !isFinite(asset.averagePrice) || 
          asset.averagePrice === null || asset.averagePrice === undefined || 
          asset.averagePrice < 0) {
        
        console.log(`Corretto prezzo medio anomalo per ${asset.cryptoSymbol}: era ${asset.averagePrice}, impostato a 0`);
        asset.averagePrice = 0;
      }
    });

    // CORREZIONE: NON rimuoviamo mai gli asset con quantità zero dal database
    // Questo permette di mantenere la continuità delle transazioni
    // Il frontend si occuperà di nasconderli nella visualizzazione se necessario
    
    portfolio.lastUpdated = new Date();
    await portfolio.save();
    console.log(`Portafoglio salvato: ${portfolio.assets.length} asset rimanenti`);
    
    // Log dello stato finale degli asset
    portfolio.assets.forEach(asset => {
      console.log(`Asset nel portafoglio: ${asset.cryptoSymbol}, Quantità=${asset.quantity}, Prezzo medio=${asset.averagePrice}`);
    });
    
    return portfolio;
  } catch (error) {
    console.error('Errore nel ricalcolo del portafoglio:', error);
    throw error;
  }
}

// Funzione per recuperare tutte le transazioni
const getAllTransactions: RequestHandler = async (req, res) => {
  try {
    const transactions = await Transaction.find({ user: 'default_user' })
      .sort({ date: -1 });
    res.json(transactions);
  } catch (error) {
    console.error('Errore nel recupero delle transazioni:', error);
    res.status(500).json({ message: 'Errore nel recupero delle transazioni' });
  }
};

// Funzione per recuperare una transazione specifica
const getTransactionById: RequestHandler = async (req, res) => {
  try {
    const transaction = await Transaction.findById(req.params.id);
    
    if (!transaction) {
      return res.status(404).json({ message: 'Transazione non trovata' });
    }
    
    res.json(transaction);
  } catch (error) {
    console.error('Errore nel recupero della transazione:', error);
    res.status(500).json({ message: 'Errore nel recupero della transazione' });
  }
};

// Funzione per aggiungere una nuova transazione
const addTransaction: RequestHandler = async (req, res) => {
  try {
    const { 
      cryptoSymbol, 
      type, 
      quantity, 
      pricePerUnit, 
      fees, 
      notes, 
      date,
      category,
      paymentMethod,
      paymentCurrency
    } = req.body;
    
    // Calcola l'importo totale
    const totalAmount = quantity * pricePerUnit;
    
    // Crea una nuova transazione
    const newTransaction = new Transaction({
      user: 'default_user',
      cryptoSymbol: cryptoSymbol.toUpperCase(),
      type,
      quantity,
      pricePerUnit,
      totalAmount,
      fees,
      notes,
      date: date || new Date(),
      category,
      paymentMethod,
      paymentCurrency: paymentCurrency ? paymentCurrency.toUpperCase() : undefined
    });
    
    await newTransaction.save();
    
    // Ricalcola l'intero portafoglio invece di aggiornarlo incrementalmente
    await recalculatePortfolio('default_user');
    
    res.status(201).json(newTransaction);
  } catch (error) {
    console.error('Errore nell\'aggiunta della transazione:', error);
    res.status(500).json({ message: 'Errore nell\'aggiunta della transazione' });
  }
};

// Funzione per registrare un airdrop
const recordAirdrop: RequestHandler = async (req, res) => {
  try {
    const {
      cryptoSymbol,
      quantity,
      date,
      notes,
      category
    } = req.body;
    
    // Verifica che i campi richiesti siano presenti
    if (!cryptoSymbol || !quantity) {
      return res.status(400).json({ 
        success: false,
        message: 'Simbolo della criptovaluta e quantità sono obbligatori' 
      });
    }
    
    // Crea una nuova transazione di tipo AIRDROP
    const newAirdrop = new Transaction({
      user: 'default_user',
      cryptoSymbol: cryptoSymbol.toUpperCase(),
      type: TransactionType.AIRDROP,
      quantity,
      pricePerUnit: 0, // Prezzo sempre a zero per gli airdrop
      totalAmount: 0,  // Importo totale sempre a zero per gli airdrop
      date: date || new Date(),
      notes,
      category
    });
    
    await newAirdrop.save();
    
    // Ricalcola l'intero portafoglio
    await recalculatePortfolio('default_user');
    
    res.status(201).json({
      success: true,
      message: `Airdrop di ${quantity} ${cryptoSymbol.toUpperCase()} registrato con successo`,
      transaction: newAirdrop
    });
  } catch (error) {
    console.error('Errore nella registrazione dell\'airdrop:', error);
    res.status(500).json({ 
      success: false,
      message: 'Errore nella registrazione dell\'airdrop',
      error: error instanceof Error ? error.message : String(error)
    });
  }
};

// Funzione per registrare una transazione di farming
const recordFarming: RequestHandler = async (req, res) => {
  try {
    const {
      cryptoSymbol,
      quantity,
      date,
      notes,
      category,
      paymentMethod = PaymentMethod.CRYPTO,  // Default a CRYPTO
      paymentCurrency                        // La crypto di origine
    } = req.body;
    
    // Verifica che i campi richiesti siano presenti
    if (!cryptoSymbol || !quantity) {
      return res.status(400).json({ 
        success: false,
        message: 'Simbolo della criptovaluta e quantità sono obbligatori' 
      });
    }
    
    // Crea una nuova transazione di tipo FARMING con i campi per la crypto di origine
    const newFarming = new Transaction({
      user: 'default_user',
      cryptoSymbol: cryptoSymbol.toUpperCase(),
      type: TransactionType.FARMING,
      quantity,
      pricePerUnit: 0,
      totalAmount: 0,
      date: date || new Date(),
      notes,
      category,
      paymentMethod,
      paymentCurrency: paymentCurrency ? paymentCurrency.toUpperCase() : cryptoSymbol.toUpperCase()
    });
    
    await newFarming.save();
    
    // Ricalcola l'intero portafoglio
    await recalculatePortfolio('default_user');
    
    res.status(201).json({
      success: true,
      message: `Farming di ${quantity} ${cryptoSymbol.toUpperCase()} registrato con successo`,
      transaction: newFarming
    });
  } catch (error) {
    console.error('Errore nella registrazione del farming:', error);
    res.status(500).json({ 
      success: false,
      message: 'Errore nella registrazione del farming',
      error: error instanceof Error ? error.message : String(error)
    });
  }
};

// Funzione per aggiornare una transazione esistente
const updateTransaction: RequestHandler = async (req, res) => {
  try {
    // Prima ottieni la transazione originale
    const originalTransaction = await Transaction.findById(req.params.id);
    if (!originalTransaction) {
      return res.status(404).json({ message: 'Transazione non trovata' });
    }
    
    // Aggiorna la transazione
    const { 
      cryptoSymbol, 
      type, 
      quantity, 
      pricePerUnit, 
      fees, 
      notes, 
      date,
      category,
      paymentMethod,
      paymentCurrency
    } = req.body;
    
    const totalAmount = quantity * pricePerUnit;
    
    const updatedTransaction = await Transaction.findByIdAndUpdate(
      req.params.id,
      {
        cryptoSymbol: cryptoSymbol.toUpperCase(),
        type,
        quantity,
        pricePerUnit,
        totalAmount,
        fees,
        notes,
        date: date || originalTransaction.date,
        category,
        paymentMethod,
        paymentCurrency: paymentCurrency ? paymentCurrency.toUpperCase() : undefined
      },
      { new: true }
    );
    
    // Ricalcola l'intero portafoglio
    await recalculatePortfolio('default_user');
    
    res.json(updatedTransaction);
  } catch (error) {
    console.error('Errore nell\'aggiornamento della transazione:', error);
    res.status(500).json({ message: 'Errore nell\'aggiornamento della transazione' });
  }
};

// Funzione per eliminare una transazione
const deleteTransaction: RequestHandler = async (req, res) => {
  try {
    // Prima ottieni la transazione
    const transaction = await Transaction.findById(req.params.id);
    if (!transaction) {
      return res.status(404).json({ message: 'Transazione non trovata' });
    }
    
    // Elimina la transazione
    await Transaction.findByIdAndDelete(req.params.id);
    
    // Ricalcola l'intero portafoglio
    await recalculatePortfolio('default_user');
    
    res.json({ message: 'Transazione eliminata con successo' });
  } catch (error) {
    console.error('Errore nell\'eliminazione della transazione:', error);
    res.status(500).json({ message: 'Errore nell\'eliminazione della transazione' });
  }
};

// Registra le route con le funzioni nominate
router.get('/', getAllTransactions);
router.get('/:id', getTransactionById);
router.post('/', addTransaction);
router.post('/airdrop', recordAirdrop);
router.post('/farming', recordFarming);
router.put('/:id', updateTransaction);
router.delete('/:id', deleteTransaction);

export default router;